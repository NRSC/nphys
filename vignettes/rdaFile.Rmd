---
title: "Introduction to navigating the rda file"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rdaFile}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, message = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message=FALSE, 
                      warning=FALSE, 
                      fig.height=5, 
                      fig.width=8,
                      collapse = TRUE,
                      comment = "#>")
library(nphys)
```

```{r setup}
library(nphys)
field = data(field)

```



When we want to quickly access any of the data associated with a data point, we load the rda file and apply functions elements of the nested list.

Loading the rda file adds a nested list to the environment containing all of the information we need to quickly and reliably analyze our data.

We also want to be able to able to nteract with the data and effeciently incorporate updated analysis into our ongoing project.

Having easy access to our data is one of the primary reasons we are doing this work.

We are going to utilize the `field` dataset,


to look at examples of how we can work with the comprehensive rda file that we've built over the course of our experiment. 

# What is in the file

After we have compiled our metadata, imported our experimental data, and loaded our rda file, we end up with a nested list (in this case `field`) in the REnvironment. 


Our nested list is made up of a number of useful components. It contains the working directory of our rda file relative to the project directory, and all of the metadata that we input during our experimental procedure. 

The call contains all of the identifying information needed for analyzing our data and adding it to our project. 

```{r}
knitr::kable(field$md[1:8], row.names = FALSE)
knitr::kable(field$md[9:15], row.names = FALSE)
```


The `field$files` component is a list of the raw data files collected during our experiment, which are also relative to the project directory.

Finally, the `field$ABF` component of our nested list contains all of the raw data imported during our experimental protocol, including any metadata that is kept by the software. We will go over importing data in another document, but for the time being it is imporant to note that UI will be required to ensure that your data will properly sort and therefore be identifiable. 

```{r}
names(field$ABF)
names(field$ABF[[1]])
```

Accessing this information is very useful when you need to identify your channels, sampling fequency, etc. 

# We can

### Extract the sweeps that make up the data.

We can extract all of the data we imported by calling the `dfs_ABF` function on our imported abf data, `i.e. field$ABF`.

```{r}
dfs <- dfs_ABF(field$ABF)
# Names of imported data
head(names(dfs))

# Individual traces are named by their sweep when defaut selections are run
names(dfs[1])
```

---

This function can also be used to extract other useful information about the imported data.

```{r}
head(dfs_ABF(field$ABF, int = "samplingIntervalInSec"),3)
```

It can be useful to simplify the output by specifying `returnList = FALSE`, which will unlist the data, potentialy making it easier to work with later.
```{r}
dfs_ABF(field$ABF, int = "samplingIntervalInSec", returnList = FALSE)
```

There are numerous parameters kept by the pClamp software that can be very useful in ordering and managing your datasets (See the ABF file format vig for more information). 

Using the select option will enable you to select from a list of elements that make up the identifying and metadata components for each imported file.

```{r eval = FALSE}
# Select from list
#dfs_ABF(field$ABF, select = TRUE, returnList = FALSE)


# Select from list
dfs_ABF(field$ABF, select = 4, returnList = FALSE)
```

---

### Pull specific sweeps or sets of sweeps from the $ABF

```{r}
tst <- pullSweeps(field$ABF)
head(names(tst))
#plot(tst[1500:3000,1], type = "line", ylim = c(-1.5,0.25), frame.plot = FALSE)
```

Options for working with the pullSweeps function allow us to select from list

```{r, eval = FALSE}
pullSweeps(field$ABF, select = TRUE)
```

or select based upon numeric input

```{r eval = FALSE}
tst = pullSweeps(field$ABF, select = 1)
names(tst)

head(tst)
```

We can also return the dataframe without adjusting the baseline
```{r}

# tst = pullSweeps(field$ABF, select = 1, zero = FALSE)
# head(tst)
```

### Adjusting the sweeps to zero

Embedded within the `pullSweeps` function there is a function that adjust the sweeps around zero referred to as `zeroAdjust`

```{r}

x = dfs_ABF(field$ABF)[[1]][[1]]
round(head(x),digits = 3)

x = zeroAdjust(x)
round(head(x),digits = 3)


```

This function can be modified to change the baseline range over which the sweep will be adjusted against.

```{r}
x = dfs_ABF(field$ABF)[[1]][[1]]
round(head(x),digits = 3)
x = zeroAdjust(x, r = 1200:1500)
round(head(x),digits = 3)

```


